const bcrypt = require('bcryptjs');
const { getPool } = require('./pg-pool');

async function ensureSchema(pool) {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS prayers (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      display_name TEXT,
      content TEXT NOT NULL,
      status TEXT DEFAULT 'PENDING' CHECK (status IN ('PENDING', 'APPROVED', 'REJECTED')),
      created_at TIMESTAMPTZ DEFAULT NOW(),
      approved_at TIMESTAMPTZ,
      approved_by TEXT,
      expires_at TIMESTAMPTZ,
      duration_days INTEGER DEFAULT 7,
      ip_hash TEXT
    )
  `);

  await pool.query(`
    CREATE TABLE IF NOT EXISTS admins (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      username TEXT UNIQUE NOT NULL,
      password_hash TEXT NOT NULL,
      created_at TIMESTAMPTZ DEFAULT NOW()
    )
  `);

  await pool.query(`
    CREATE TABLE IF NOT EXISTS audit_log (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      event_type TEXT NOT NULL,
      prayer_id BIGINT,
      admin_username TEXT,
      ip_hash TEXT,
      details TEXT,
      created_at TIMESTAMPTZ DEFAULT NOW()
    )
  `);

  await pool.query('CREATE INDEX IF NOT EXISTS idx_prayers_status ON prayers(status)');
  await pool.query('CREATE INDEX IF NOT EXISTS idx_prayers_created_at ON prayers(created_at)');
  await pool.query('CREATE INDEX IF NOT EXISTS idx_prayers_expires_at ON prayers(expires_at)');
  await pool.query('CREATE INDEX IF NOT EXISTS idx_audit_log_event_type ON audit_log(event_type)');
  await pool.query('CREATE INDEX IF NOT EXISTS idx_audit_log_created_at ON audit_log(created_at)');
}

async function initPostgres() {
  const pool = getPool();

  await ensureSchema(pool);

  async function initializeAdmin() {
    const username = process.env.ADMIN_USERNAME;
    const password = process.env.ADMIN_PASSWORD;

    if (!username || !password) {
      console.log('[DB] No ADMIN_USERNAME or ADMIN_PASSWORD in .env, skipping admin initialization');
      return;
    }

    const existing = await pool.query('SELECT id FROM admins WHERE username = $1', [username]);
    if (existing.rows.length === 0) {
      const passwordHash = bcrypt.hashSync(password, 12);
      await pool.query(
        'INSERT INTO admins (username, password_hash) VALUES ($1, $2)',
        [username, passwordHash]
      );
      console.log(`[DB] Created initial admin account: ${username}`);
    } else {
      console.log(`[DB] Admin account '${username}' already exists`);
    }
  }

  async function cleanupOldData() {
    const deletedPrayers = await pool.query(`
      DELETE FROM prayers
      WHERE status = 'REJECTED'
      AND approved_at < NOW() - INTERVAL '60 days'
    `);

    const deletedLogs = await pool.query(`
      DELETE FROM audit_log
      WHERE created_at < NOW() - INTERVAL '60 days'
    `);

    if (deletedPrayers.rowCount > 0 || deletedLogs.rowCount > 0) {
      console.log(`[DB] Cleanup: Deleted ${deletedPrayers.rowCount} old rejected prayers, ${deletedLogs.rowCount} old logs`);
    }
  }

  const prayerOps = {
    create: {
      run: async (params) => {
        const displayName = params && params.displayName ? params.displayName : null;
        const content = params && params.content ? params.content : '';
        const ipHash = params && params.ipHash ? params.ipHash : null;
        const durationDays = params && params.durationDays ? params.durationDays : 7;

        const result = await pool.query(
          `
            INSERT INTO prayers (display_name, content, ip_hash, duration_days)
            VALUES ($1, $2, $3, $4)
            RETURNING id
          `,
          [displayName, content, ipHash, durationDays]
        );

        return {
          lastInsertRowid: result.rows[0].id,
          changes: result.rowCount
        };
      }
    },
    getApproved: {
      all: async () => {
        const result = await pool.query(`
          SELECT id, display_name, content, created_at, approved_at, expires_at
          FROM prayers
          WHERE status = 'APPROVED'
          AND (expires_at IS NULL OR expires_at > NOW())
          ORDER BY approved_at DESC
        `);
        return result.rows;
      }
    },
    getApprovedAll: {
      all: async () => {
        const result = await pool.query(`
          SELECT id, display_name, content, created_at, approved_at, expires_at
          FROM prayers
          WHERE status = 'APPROVED'
          ORDER BY approved_at DESC
        `);
        return result.rows;
      }
    },
    getExpired: {
      all: async () => {
        const result = await pool.query(`
          SELECT id, display_name, content, created_at, approved_at, expires_at
          FROM prayers
          WHERE status = 'APPROVED'
          AND expires_at IS NOT NULL
          AND expires_at <= NOW()
          ORDER BY expires_at DESC
        `);
        return result.rows;
      }
    },
    getPending: {
      all: async () => {
        const result = await pool.query(`
          SELECT id, display_name, content, created_at, ip_hash, duration_days
          FROM prayers
          WHERE status = 'PENDING'
          ORDER BY created_at ASC
        `);
        return result.rows;
      }
    },
    getRejected: {
      all: async () => {
        const result = await pool.query(`
          SELECT id, display_name, content, created_at, approved_at, approved_by
          FROM prayers
          WHERE status = 'REJECTED'
          ORDER BY approved_at DESC
          LIMIT 50
        `);
        return result.rows;
      }
    },
    getById: {
      get: async (id) => {
        const result = await pool.query('SELECT * FROM prayers WHERE id = $1', [id]);
        return result.rows[0];
      }
    },
    approve: {
      run: async (params) => {
        const id = params ? params.id : null;
        const adminUsername = params && params.adminUsername ? params.adminUsername : null;
        const result = await pool.query(
          `
            UPDATE prayers
            SET status = 'APPROVED',
                approved_at = NOW(),
                approved_by = $2,
                expires_at = NOW() + (COALESCE(duration_days, 7) || ' days')::interval
            WHERE id = $1 AND status = 'PENDING'
          `,
          [id, adminUsername]
        );
        return { changes: result.rowCount };
      }
    },
    approveAll: {
      run: async (params) => {
        const adminUsername = params && params.adminUsername ? params.adminUsername : null;
        const result = await pool.query(
          `
            UPDATE prayers
            SET status = 'APPROVED',
                approved_at = NOW(),
                approved_by = $1,
                expires_at = NOW() + (COALESCE(duration_days, 7) || ' days')::interval
            WHERE status = 'PENDING'
          `,
          [adminUsername]
        );
        return { changes: result.rowCount };
      }
    },
    reject: {
      run: async (params) => {
        const id = params ? params.id : null;
        const adminUsername = params && params.adminUsername ? params.adminUsername : null;
        const result = await pool.query(
          `
            UPDATE prayers
            SET status = 'REJECTED',
                approved_at = NOW(),
                approved_by = $2
            WHERE id = $1 AND status IN ('PENDING', 'APPROVED')
          `,
          [id, adminUsername]
        );
        return { changes: result.rowCount };
      }
    },
    extendExpiry: {
      run: async (params) => {
        const id = params ? params.id : null;
        const result = await pool.query(
          `
            UPDATE prayers
            SET expires_at = COALESCE(expires_at, NOW()) + INTERVAL '7 days'
            WHERE id = $1 AND status = 'APPROVED'
          `,
          [id]
        );
        return { changes: result.rowCount };
      }
    },
    setExpiryDate: {
      run: async (params) => {
        const id = params ? params.id : null;
        const expiresAt = params ? params.expiresAt : null;
        const result = await pool.query(
          `
            UPDATE prayers
            SET expires_at = $2
            WHERE id = $1 AND status = 'APPROVED'
          `,
          [id, expiresAt]
        );
        return { changes: result.rowCount };
      }
    },
    recoverWithExpiry: {
      run: async (params) => {
        const id = params ? params.id : null;
        const adminUsername = params && params.adminUsername ? params.adminUsername : null;
        const expiresAt = params ? params.expiresAt : null;
        const result = await pool.query(
          `
            UPDATE prayers
            SET status = 'APPROVED',
                approved_at = NOW(),
                approved_by = $2,
                expires_at = COALESCE($3::timestamptz, NOW() + (COALESCE(duration_days, 7) || ' days')::interval)
            WHERE id = $1 AND status = 'REJECTED'
          `,
          [id, adminUsername, expiresAt]
        );
        return { changes: result.rowCount };
      }
    },
    updateContent: {
      run: async (params) => {
        const id = params ? params.id : null;
        const displayName = params && params.displayName ? params.displayName : null;
        const content = params && params.content ? params.content : '';
        const result = await pool.query(
          `
            UPDATE prayers
            SET display_name = $2,
                content = $3
            WHERE id = $1 AND status IN ('PENDING', 'APPROVED')
          `,
          [id, displayName, content]
        );
        return { changes: result.rowCount };
      }
    },
    countRecentByIp: {
      get: async (ipHash) => {
        const result = await pool.query(
          `
            SELECT COUNT(*)::int AS count
            FROM prayers
            WHERE ip_hash = $1
            AND created_at > NOW() - INTERVAL '5 minutes'
          `,
          [ipHash]
        );
        return result.rows[0];
      }
    }
  };

  const adminOps = {
    getByUsername: {
      get: async (username) => {
        const result = await pool.query('SELECT * FROM admins WHERE username = $1', [username]);
        return result.rows[0];
      }
    },
    getById: {
      get: async (id) => {
        const result = await pool.query(
          'SELECT id, username, created_at FROM admins WHERE id = $1',
          [id]
        );
        return result.rows[0];
      }
    },
    getAll: {
      all: async () => {
        const result = await pool.query(
          'SELECT id, username, created_at FROM admins ORDER BY created_at'
        );
        return result.rows;
      }
    },
    create: {
      run: async (params) => {
        const username = params && params.username ? params.username : null;
        const passwordHash = params && params.passwordHash ? params.passwordHash : null;
        const result = await pool.query(
          'INSERT INTO admins (username, password_hash) VALUES ($1, $2)',
          [username, passwordHash]
        );
        return { changes: result.rowCount };
      }
    },
    updatePassword: {
      run: async (params) => {
        const id = params ? params.id : null;
        const passwordHash = params && params.passwordHash ? params.passwordHash : null;
        const result = await pool.query(
          'UPDATE admins SET password_hash = $2 WHERE id = $1',
          [id, passwordHash]
        );
        return { changes: result.rowCount };
      }
    },
    delete: {
      run: async (id) => {
        const result = await pool.query('DELETE FROM admins WHERE id = $1', [id]);
        return { changes: result.rowCount };
      }
    },
    count: {
      get: async () => {
        const result = await pool.query('SELECT COUNT(*)::int AS count FROM admins');
        return result.rows[0];
      }
    }
  };

  const auditOps = {
    log: {
      run: async (params) => {
        const eventType = params && params.eventType ? params.eventType : null;
        const prayerId = params && params.prayerId ? params.prayerId : null;
        const adminUsername = params && params.adminUsername ? params.adminUsername : null;
        const ipHash = params && params.ipHash ? params.ipHash : null;
        const details = params && params.details ? params.details : null;
        const result = await pool.query(
          `
            INSERT INTO audit_log (event_type, prayer_id, admin_username, ip_hash, details)
            VALUES ($1, $2, $3, $4, $5)
          `,
          [eventType, prayerId, adminUsername, ipHash, details]
        );
        return { changes: result.rowCount };
      }
    },
    getRecent: {
      all: async (limit) => {
        const result = await pool.query(
          'SELECT * FROM audit_log ORDER BY created_at DESC LIMIT $1',
          [Number(limit) || 50]
        );
        return result.rows;
      }
    }
  };

  return {
    db: pool,
    initializeAdmin,
    cleanupOldData,
    prayerOps,
    adminOps,
    auditOps
  };
}

module.exports = initPostgres;
